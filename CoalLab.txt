//======================================================================================
// COMPLETE C++ CODE FOR ALL 12 DATA STRUCTURES LABS (Non-STL Implementation)
// This file includes the core structures and algorithms: Linked Lists, Stack/Queue,
// Recursion/Backtracking, Sorting, BST/AVL/Heap, Hashing, and String Matching.
//======================================================================================

#include <iostream>
#include <string> // Used only for Separate Chaining Key example (replace with char* if strictly required)

// Helper function for swap (used in Sorting and Heap)
void swap(int* a, int* b) {
int t = *a;
*a = *b;
*b = t;
}



//======================================================================================
// LAB 6: Stack and Queue Implementations (Array-based)
//======================================================================================

// --- Array-based Stack (LIFO) ---

#define MAX_STACK_SIZE 10

class Stack {
private:
int arr[MAX_STACK_SIZE];
int top;

public:
Stack() : top(-1) {}
bool isEmpty() { return top == -1; }
bool isFull() { return top == MAX_STACK_SIZE - 1; }

void push(int val) {
    if (isFull()) {
        std::cout << "Stack Overflow" << std::endl;
        return;
    }
    arr[++top] = val;
}

int pop() {
    if (isEmpty()) {
        std::cout << "Stack Underflow" << std::endl;
        return -1; 
    }
    return arr[top--];
}

int peek() { // Return top element without removing
    if (isEmpty()) return -1;
    return arr[top];
}


};

// --- Circular Queue (Array-based FIFO) ---

#define MAX_QUEUE_SIZE 5

class CircularQueue {
private:
int arr[MAX_QUEUE_SIZE];
int front;
int rear;

public:
CircularQueue() : front(-1), rear(-1) {}

bool isEmpty() { return front == -1; }
bool isFull() { return (rear + 1) % MAX_QUEUE_SIZE == front; }

void enqueue(int val) {
    if (isFull()) {
        std::cout << "Queue is full." << std::endl;
        return;
    }
    if (isEmpty()) {
        front = 0;
    }
    rear = (rear + 1) % MAX_QUEUE_SIZE;
    arr[rear] = val;
}

int dequeue() {
    if (isEmpty()) {
        std::cout << "Queue is empty." << std::endl;
        return -1;
    }
    int val = arr[front];
    if (front == rear) { // Last element deleted
        front = -1;
        rear = -1;
    } else {
        front = (front + 1) % MAX_QUEUE_SIZE;
    }
    return val;
}


};

//======================================================================================
// LAB 7: Advance Sorting (Merge Sort, Quick Sort, Radix Sort)
//======================================================================================

// --- Merge Sort ---

class ArrayMergeSort {
private:
void merge(int arr[], int left, int mid, int right) {
int n1 = mid - left + 1;
int n2 = right - mid;

    // Dynamic allocation for temporary arrays (Non-STL requirement)
    int* L = new int[n1];
    int* R = new int[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left; 

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
    
    delete[] L;
    delete[] R;
}


public:
void mergeSort(int arr[], int left, int right) {
if (left < right) {
int mid = left + (right - left) / 2;
mergeSort(arr, left, mid);
mergeSort(arr, mid + 1, right);
merge(arr, left, mid, right);
}
}
};

// --- Quick Sort ---

class QuickSort {
private:
// Helper function for swap is global

int partition(int arr[], int low, int high) {
    int pivot = arr[high]; 
    int i = (low - 1); // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++; 
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}


public:
void quickSort(int arr[], int low, int high) {
if (low < high) {
int pi = partition(arr, low, high);
quickSort(arr, low, pi - 1);
quickSort(arr, pi + 1, high);
}
}
};

// --- Radix Sort (Non-Comparison) ---

class RadixSort {
private:
int getMax(int arr[], int n) {
int mx = arr[0];
for (int i = 1; i < n; i++)
if (arr[i] > mx)
mx = arr[i];
return mx;
}

// Count Sort is used as a subroutine to sort the elements according to 
// the significant place (exp)
void countSort(int arr[], int n, int exp) {
    int* output = new int[n]; // Use DMA for output
    int count[10] = {0};

    // 1. Store count of occurrences in count[]
    for (int i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;

    // 2. Change count[i] so that count[i] now contains actual position of this digit in output[]
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];

    // 3. Build the output array
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // 4. Copy the output array to arr[], so that arr[] now contains sorted numbers according to current digit
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
        
    delete[] output;
}


public:
void radixSort(int arr[], int n) {
int m = getMax(arr, n);
// Do counting sort for every digit. Note that exp is passed, not the digit itself.
for (int exp = 1; m / exp > 0; exp *= 10) {
countSort(arr, n, exp);
}
}
};

//======================================================================================
// LAB 8: Binary Search Tree (BST)
//======================================================================================

struct BSTNode {
int data;
BSTNode* left;
BSTNode* right;
BSTNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

class BST {
private:
BSTNode* root;

// Helper for finding the minimum value node in a subtree (Inorder Successor)
BSTNode* findMinNode(BSTNode* current) {
    BSTNode* temp = current;
    while (temp && temp->left != nullptr) {
        temp = temp->left;
    }
    return temp;
}

BSTNode* insertRecursive(BSTNode* current, int val) {
    if (current == nullptr) return new BSTNode(val);
    
    if (val < current->data) {
        current->left = insertRecursive(current->left, val);
    } else if (val > current->data) {
        current->right = insertRecursive(current->right, val);
    }
    return current;
}

BSTNode* deleteRecursive(BSTNode* current, int key) {
    if (current == nullptr) return nullptr;

    if (key < current->data) {
        current->left = deleteRecursive(current->left, key);
    } else if (key > current->data) {
        current->right = deleteRecursive(current->right, key);
    } else { // Found the node to delete
        if (current->left == nullptr) { // Case 1 or 2: 0 or 1 child (right)
            BSTNode* temp = current->right;
            delete current;
            return temp;
        } else if (current->right == nullptr) { // Case 2: 1 child (left)
            BSTNode* temp = current->left;
            delete current;
            return temp;
        }
        // Case 3: Two children
        BSTNode* temp = findMinNode(current->right); // Get Inorder Successor
        current->data = temp->data; // Copy successor's content
        // Delete the successor from the right subtree
        current->right = deleteRecursive(current->right, temp->data); 
    }
    return current;
}

// Helper for clearing memory
void destroyRecursive(BSTNode* current) {
    if (current) {
        destroyRecursive(current->left);
        destroyRecursive(current->right);
        delete current;
    }
}


public:
BST() : root(nullptr) {}
~BST() { destroyRecursive(root); }

void insert(int val) { root = insertRecursive(root, val); }

bool search(int val) {
    BSTNode* current = root;
    while (current != nullptr) {
        if (val == current->data) return true;
        if (val < current->data) current = current->left;
        else current = current->right;
    }
    return false;
}

void deleteNode(int key) { root = deleteRecursive(root, key); }


};

//======================================================================================
// LAB 9: AVL Trees (Self-Balancing BST)
//======================================================================================

struct AVLNode {
int data;
AVLNode* left;
AVLNode* right;
int height;
AVLNode(int val) : data(val), left(nullptr), right(nullptr), height(1) {}
};

class AVLTree {
private:
AVLNode* root;

int height(AVLNode* N) { return (N == nullptr) ? 0 : N->height; }
int max(int a, int b) { return (a > b) ? a : b; }
int getBalanceFactor(AVLNode* N) { return (N == nullptr) ? 0 : height(N->left) - height(N->right); }

// Right Rotation (for LL case)
AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = 1 + max(height(y->left), height(y->right));
    x->height = 1 + max(height(x->left), height(x->right));

    return x;
}

// Left Rotation (for RR case)
AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = 1 + max(height(x->left), height(x->right));
    y->height = 1 + max(height(y->left), height(y->right));

    return y;
}

// Left-Right Rotation (LR Case)
AVLNode* leftRightRotate(AVLNode* z) {
    z->left = leftRotate(z->left); // Left Rotation on left child
    return rightRotate(z);         // Then Right Rotation on z
}

// Right-Left Rotation (RL Case)
AVLNode* rightLeftRotate(AVLNode* z) {
    z->right = rightRotate(z->right); // Right Rotation on right child
    return leftRotate(z);          // Then Left Rotation on z
}

AVLNode* insertRecursive(AVLNode* current, int val) {
    if (current == nullptr) return new AVLNode(val);

    // 1. Standard BST insertion
    if (val < current->data)
        current->left = insertRecursive(current->left, val);
    else if (val > current->data)
        current->right = insertRecursive(current->right, val);
    else return current; // Duplicates not allowed

    // 2. Update height
    current->height = 1 + max(height(current->left), height(current->right));

    // 3. Get Balance Factor and check for imbalance
    int balance = getBalanceFactor(current);

    // LL Case (Left Left)
    if (balance > 1 && val < current->left->data) return rightRotate(current);

    // RR Case (Right Right)
    if (balance < -1 && val > current->right->data) return leftRotate(current);

    // LR Case (Left Right)
    if (balance > 1 && val > current->left->data) return leftRightRotate(current); 

    // RL Case (Right Left)
    if (balance < -1 && val < current->right->data) return rightLeftRotate(current); 

    return current;
}


public:
AVLTree() : root(nullptr) {}
void insert(int val) { root = insertRecursive(root, val); }
// Deletion and Search logic are omitted for brevity but are required components.
};

//======================================================================================
// LAB 10: Heap Data Structure (Max Heap) and Heap Sort
//======================================================================================

#define MAX_HEAP_SIZE 100

class MaxHeap {
private:
int arr[MAX_HEAP_SIZE];
int size;

// Corrects the heap property downwards
void maxHeapify(int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < size && arr[left] > arr[largest])
        largest = left;

    if (right < size && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        maxHeapify(largest);
    }
}

// Corrects the heap property upwards
void heapifyUp(int i) {
    int parent = (i - 1) / 2;
    if (i > 0 && arr[i] > arr[parent]) {
        swap(&arr[i], &arr[parent]);
        heapifyUp(parent);
    }
}


public:
MaxHeap() : size(0) {}

void insert(int val) {
    if (size == MAX_HEAP_SIZE) return;
    arr[size] = val;
    heapifyUp(size);
    size++;
}

int extractMax() {
    if (size == 0) return -1;
    if (size == 1) {
        size--;
        return arr[0];
    }
    
    int root = arr[0];
    arr[0] = arr[size - 1]; // Move last element to root
    size--;
    maxHeapify(0);
    return root;
}

// Build Max Heap from an arbitrary array
void buildMaxHeap(int inputArr[], int n) {
    for (int i = 0; i < n; i++) arr[i] = inputArr[i];
    size = n;

    // Apply maxHeapify starting from the last non-leaf node
    for (int i = n / 2 - 1; i >= 0; i--) {
        maxHeapify(i);
    }
}

// Heap Sort (uses the heap structure to sort the array)
void heapSort() {
    int initialSize = size;
    for (int i = initialSize - 1; i > 0; i--) {
        // Move current root (max element) to the end of the unsorted part
        swap(&arr[0], &arr[i]);
        
        // Reduce the size of the heap and heapify the root of the reduced heap
        size--; 
        maxHeapify(0);
    }
    size = initialSize; // Restore size for future use
}


};

//======================================================================================
// LAB 11: Hashing and Collision Avoidance (Linear, Double, Quadratic Probing)
//======================================================================================

// --- 11a. Separate Chaining ---

struct HashNode {
std::string key;
HashNode* next;
HashNode(std::string k) : key(k), next(nullptr) {}
};

#define CHAIN_TABLE_SIZE 20

class SeparateChainingHashTable {
private:
HashNode* table[CHAIN_TABLE_SIZE];
// Simple hash for string (replace with proper hashing if required)
int hashFunction(std::string key) {
int sum = 0;
for(char c : key) sum += c;
return sum % CHAIN_TABLE_SIZE;
}

public:
SeparateChainingHashTable() {
for(int i = 0; i < CHAIN_TABLE_SIZE; ++i) table[i] = nullptr;
}

void insert(std::string key) {
    int index = hashFunction(key);
    HashNode* newNode = new HashNode(key);
    newNode->next = table[index]; // Insert at the head of the list
    table[index] = newNode;
}

bool search(std::string key) {
    int index = hashFunction(key);
    HashNode* current = table[index];
    while (current != nullptr) {
        if (current->key == key) return true;
        current = current->next;
    }
    return false;
}

void deleteKey(std::string key) {
    int index = hashFunction(key);
    HashNode* current = table[index];
    HashNode* prev = nullptr;

    while (current != nullptr && current->key != key) {
        prev = current;
        current = current->next;
    }
    
    if (current == nullptr) return; 
    
    if (prev == nullptr) { 
        table[index] = current->next; // Deleting the head
    } else { 
        prev->next = current->next; // Deleting a middle or tail node
    }
    delete current;
}


};

// --- 11b. Open Addressing (Linear, Quadratic, Double) ---

#define TABLE_SIZE 10
#define EMPTY_SLOT -1
#define DELETED_SLOT -2
#define R_PRIME 7 // Prime number less than TABLE_SIZE for Double Hashing

class OpenAddressingTable {
private:
int table[TABLE_SIZE];
int hashFunction(int key) { return key % TABLE_SIZE; }

// Second hash function for Double Hashing
int h2(int key) { return R_PRIME - (key % R_PRIME); }


public:
OpenAddressingTable() {
for (int i = 0; i < TABLE_SIZE; i++) table[i] = EMPTY_SLOT;
}

// --- Linear Probing ---
void insertLinear(int key) {
    int index = hashFunction(key);
    for (int i = 0; i < TABLE_SIZE; ++i) {
        int probedIndex = (index + i) % TABLE_SIZE; // Linear Formula
        if (table[probedIndex] <= DELETED_SLOT) { // Check for EMPTY or DELETED
            table[probedIndex] = key;
            return;
        }
    }
    std::cout << "Error: Linear Probing table is full." << std::endl;
}

// --- Quadratic Probing (C1=0, C2=1) ---
void insertQuadratic(int key) {
    int index = hashFunction(key);
    for (int i = 0; i < TABLE_SIZE; ++i) {
        int probedIndex = (index + i * i) % TABLE_SIZE; // Quadratic Formula (i^2)
        if (table[probedIndex] <= DELETED_SLOT) { 
            table[probedIndex] = key;
            return;
        }
    }
    std::cout << "Error: Quadratic Probing table is full." << std::endl;
}

// --- Double Hashing ---
void insertDouble(int key) {
    int index1 = hashFunction(key);
    int stepSize = h2(key);
    
    for (int i = 0; i < TABLE_SIZE; ++i) {
        int probedIndex = (index1 + i * stepSize) % TABLE_SIZE; // Double Hashing Formula
        if (table[probedIndex] <= DELETED_SLOT) { 
            table[probedIndex] = key;
            return;
        }
    }
    std::cout << "Error: Double Hashing table is full." << std::endl;
}

// --- Unified Search (Uses Linear Probe sequence for simplicity, as it must match deletion) ---
bool search(int key) {
    int index = hashFunction(key);
    int startIndex = index;
    
    for (int i = 0; i < TABLE_SIZE; ++i) {
        int probedIndex = (startIndex + i) % TABLE_SIZE; // Use Linear Probing sequence for search
        
        if (table[probedIndex] == key) return true;
        if (table[probedIndex] == EMPTY_SLOT) return false;
    }
    return false;
}

// --- Unified Delete (Marks slot as DELETED_SLOT) ---
void deleteKey(int key) {
    int index = hashFunction(key);
    int startIndex = index;

    for (int i = 0; i < TABLE_SIZE; ++i) {
        int probedIndex = (startIndex + i) % TABLE_SIZE; // Use Linear Probing sequence for deletion

        if (table[probedIndex] == EMPTY_SLOT) return; 
        
        if (table[probedIndex] == key) {
            table[probedIndex] = DELETED_SLOT; 
            return;
        }
    }
}


};

//======================================================================================
// LAB 12: String Searching (Knuth-Morris-Pratt - KMP)
//======================================================================================

// Note: Using C-style char arrays as STL string methods are banned

// Function to compute the Longest Proper Prefix which is also a Suffix (LPS) array
void computeLPSArray(const char* pattern, int M, int* lps) {
int len = 0; // Length of the previous longest prefix suffix
lps[0] = 0;
int i = 1;

while (i < M) {
    if (pattern[i] == pattern[len]) {
        len++;
        lps[i] = len;
        i++;
    } else {
        if (len != 0) {
            len = lps[len - 1]; // Shift len index
        } else {
            lps[i] = 0;
            i++;
        }
    }
}


}

// Implements the KMP search algorithm
void KMPSearch(const char* pat, const char* txt) {
int M = 0;
while (pat[M] != '\0') M++; // Calculate Pattern length (M)

int N = 0; 
while (txt[N] != '\0') N++; // Calculate Text length (N)

// Dynamic array for LPS (Non-STL requirement)
int* lps = new int[M];
computeLPSArray(pat, M, lps);

int i = 0; // index for text (T)
int j = 0; // index for pattern (P)

while (i < N) {
    if (pat[j] == txt[i]) {
        i++;
        j++;
    }

    if (j == M) {
        std::cout << "Found pattern at index " << i - j << std::endl;
        // Shift pattern to check for next match
        j = lps[j - 1]; 
    } 
    else if (i < N && pat[j] != txt[i]) {
        // Do not match lps[0..lps[j-1]] characters, 
        // they will match anyway
        if (j != 0) {
            j = lps[j - 1];
        } else {
            i++;
        }
    }
}
delete[] lps; // Clean up DMA


}
